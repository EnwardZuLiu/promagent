// Copyright 2017 The Promagent Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package io.promagent.hooks;

import io.promagent.annotations.After;
import io.promagent.annotations.Before;
import io.promagent.annotations.Hook;
import io.promagent.internal.Context;
import io.promagent.metrics.Metrics;

import java.util.HashSet;
import java.util.Set;
import java.util.concurrent.TimeUnit;

@Hook(instruments = {
        "java.sql.Statement",
        "java.sql.Connection"
})
public class JdbcHook {

    private long startTime = 0;
    private boolean relevant = false;

    private String stripValues(String query) {
        // We want the structure of the query as labels, not the actual values.
        // Therefore, we replace:
        // insert into Member (id, name, email, phone_number) values (0, 'John Smith', 'john.smith@mailinator.com', '2125551212')
        // with
        // insert into Member (id, name, email, phone_number) values (...)
        return query.replaceAll("values\\s*\\(.*?\\)", "values (...)");
    }

    // --- before

    @Before(method = {"execute", "executeQuery", "executeUpdate", "executeLargeUpdate", "prepareStatement", "prepareCall"})
    public void before(String sql) {
        if (getRunningQueries().contains(sql)) {
            // This is a nested call, i.e. this Statement or Connection is called from within another Statement or Connection.
            // We only instrument the outer-most call and ignore nested calls.
            // Returning here will leave the variable relevant=false, so the @After method does not do anything.
            return;
        }
        getRunningQueries().add(sql);
        relevant = true;
        startTime = System.nanoTime();
    }

    @Before(method = {"execute", "executeUpdate", "executeLargeUpdate", "prepareStatement"})
    public void before(String sql, int autoGeneratedKeys) {
        before(sql);
    }

    @Before(method = {"execute", "executeUpdate", "executeLargeUpdate", "prepareStatement"})
    public void before(String sql, int[] columnIndexes) {
        before(sql);
    }

    @Before(method = {"execute", "executeUpdate", "executeLargeUpdate", "prepareStatement"})
    public void before(String sql, String[] columnNames) {
        before(sql);
    }

    @Before(method = {"prepareStatement", "prepareCall"})
    public void before(String sql, int resultSetType, int resultSetConcurrency) {
        before(sql);
    }

    @Before(method = {"prepareStatement", "prepareCall"})
    public void before(String sql, int resultSetType, int resultSetConcurrency, int resultSetHoldability) {
        before(sql);
    }

    // --- after

    @After(method = {"execute", "executeQuery", "executeUpdate", "executeLargeUpdate", "prepareStatement", "prepareCall"})
    public void after(String sql) throws Exception {
        if (relevant) {
            try {
                double duration = ((double) System.nanoTime() - startTime) / (double) TimeUnit.SECONDS.toNanos(1L);
                String method = Context.get(Context.SERVLET_HOOK_METHOD).orElse("no http context");
                String path = Context.get(Context.SERVLET_HOOK_PATH).orElse("no http context");
                String query = stripValues(sql);
                Metrics.sqlQueriesTotal.labels(method, path, query).inc();
                Metrics.sqlQueriesDuration.labels(method, path, query).observe(duration);
            } finally {
                getRunningQueries().remove(sql);
            }
        }
    }

    @After(method = {"execute", "executeUpdate", "executeLargeUpdate", "prepareStatement"})
    public void after(String sql, int autoGeneratedKeys) throws Exception {
        after(sql);
    }

    @After(method = {"execute", "executeUpdate", "executeLargeUpdate", "prepareStatement"})
    public void after(String sql, int[] columnIndexes) throws Exception {
        after(sql);
    }

    @After(method = {"execute", "executeUpdate", "executeLargeUpdate", "prepareStatement"})
    public void after(String sql, String[] columnNames) throws Exception {
        after(sql);
    }

    @After(method = {"prepareStatement", "prepareCall"})
    public void after(String sql, int resultSetType, int resultSetConcurrency) throws Exception {
        after(sql);
    }

    @After(method = {"prepareStatement", "prepareCall"})
    public void after(String sql, int resultSetType, int resultSetConcurrency, int resultSetHoldability) throws Exception {
        after(sql);
    }

    // ---

    private Set<String> getRunningQueries() {
        if (!Context.get(Context.JDBC_HOOK_QUERY).isPresent()) {
            Context.put(Context.JDBC_HOOK_QUERY, new HashSet<>());
        }
        return Context.get(Context.JDBC_HOOK_QUERY).get();
    }
}
